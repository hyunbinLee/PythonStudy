# PythonStudy
파이썬 공부 할 때 필요한 정보들을 저장해 놓는 공간


numPy 는 Numerical(수에 관한) Python의 줄임 말로써
딥러닝을 공부하다보면 흔하게 볼 수 있는 python의 라이브러리 이기도 하다.
도대체 무슨 역할을 하기에 이렇게 나오는 것일까?
1. Numpy 특징
벡터, 메트릭스, 고수준의 배열은 과학계산에 있어 필수 도구이다.
파이썬 계산에서 배열을 다루기 좋은 구조를 제공하는 라이브러리가 바로 Numpy 이다.
Numpy의 핵심 기능은 c로 구현되어 있다. 그래서 배열을 계산하고 처리하는데 효율적인 기능들을 제공하고, 속도 또한 빠르다.
많은 사람들이 다차원 배열을 구현할 때 numpy를 이용하며, numpy에서는 이름 ndarray라고 부른다.
결론적으로 딥러닝 구현 시 배열과 행렬의 계산이 많은데 Numpy의 배열 클래스 numpy.array에는 이를 위한 method가 많이 있어 딥러닝에서 많이 사용되는 것이다.
2. Numpy  기본적인 사용
numpy는 보통 import하여 사용되고 보통 다음과 같이 포함하여 np로 줄여서 사용된다.
import numpy as np
기본적으로 사용되는 것들은 다음과 같이다.
1차원 배열을 생성하기
x1 = np.array([1.0, 2.0, 3.0])
y1 = np.array([5.0, 10.0, 15.0])

2차원 배열 생성하기
x2 = np.array([[1.0, 2.0], [3.0, 4.0]])
y2 = np.array([[5.0, 10.0], [15.0, 20.0]])
임의로 행렬의 사이즈와 값을 동시에 지정이 가능하다.

Numpy 배열 원소 접근하기
print(x1[0])
print(x2[1][0])

Numpy 배열 계산하기
print(x1+y1)
print(x1-y1)

1로 초기화된 행렬 생성, x와y는 길이를 뜻한다.
np.one((x, y))

0으로 초기화된 행렬 생성, x와y는 길이를 뜻한다.
np.zeros((x, y))

단위행렬 생성, y가 4이면 4x4 행렬 생성
np.eye(y) 
3. shape와 dtype
n차원 배열에서 그 배열의 각 차원의 원소 수를 형상이라 하며 shape로 알 수 있다.

>>> x = np.array([[1, 2], [3, 4]])
>>> x.shape
(2, 2)

배열에 담긴 원소의 자료형은 dtype으로 알 수 있다.

>>>x.dtype
dtype('int32')
4. 브로드캐스팅 (broadcasting)
 넘파이의 ndarray 객체는 리스트와 달리 브로드캐스트라 불리는 특성이 있는 데 
이는 리스트 객체와 확연히 구별되는 기능이다. 
다음과 같이 숫자로만 이루어진 중첩 리스트 la를 고려해 보자

>>> la = [ [1, 2], [3, 4] ]

 이 리스트는 모두 숫자이지만 la+2, la/4 와 같은 연산은 지원하지 않는다. 모든 요소에 2를 더하려면 for 반복문을 사용해야만 한다. 그리고 la*2는 파이썬 문법상 전혀 다른 동작을 수행한다. 
 즉, 리스트 사이의 사칙연산은 수학 연산과는 전현 관계가 없는 것이다.
예)
>>>la*2
[[1, 2], [3, 4], [1, 2], [3, 4] ]

이에 반해서 ndarray는 요소간 연산이 기본적으로 가능하며 같은 크기의 객체간 산술연산은 요소끼리 행해져서 
그 결과가 산출된다. 
예)
>>> a = np.array(la)
>>> b = np.array( [ [1, 2], [3, 4] ])
>>> a+1
array ([[2, 3], [4, 5]])
>>>b*3
array ([[15, 18], [21, 24]])
numpy에서는 형상이 다른 배열끼리도 계산할 수 있다.
예)
>>> x = np.array([[1,2], [3, 4]])
>>> y = np.array([10, 20])
>>> x*y
array([[10, 40],  [30, 80]])

5. 다차원 배열
다차원 배열도 그 기본은 '숫자의 집합'이다. 숫자가 한 줄로 늘어선 것이나 직사각형으로 늘어놓은 것, 3차원, n차원을 통틀어 다차원 배열이라고 한다. 다음은 1차원 배열이다.
 
numpy를 import하여 np라 지정하였다.
np.array 형태의 리스트를 만들어 A에 복하였다.
때문에 A를 출력해보면 좀전에 입력한 리스트의 형태가 나온다.
np.ndim()은 배열의 차원 수를 알려주는 기능을한다.
여기서는 1차원 배열을 사용하였기에 1차원으로 나온다.
.shape 는 배열의 형상을 알려준다. 원소 4개로 구성되어 있기에 (4,) 라는 결과 값이 나왔다. 왜 4가 아니고 (4, )인지는 2차원을 보면 이해가 된다.
다음은 2차원 배열이다.
 
여기에는 '3x2' 배열인 B를 작성했습니다. 처음에는 원소가 3개, 다음 차원에는 원소가 2개 있다는 의미 입니다.
때문에 B.shape는 (3, 2) 라는 결과 값이 나오며
A.shape는 (4, 1) 라는 결과 값이 나오게 됩니다. 튜플을 반환하기 때문인데 아직 다른 글에서 다루지 않았기에 그렇구나하고 넘어가셔도 됩니다.
2차원 배열은 특히 행렬(matrix) 이라고 부르고 가로방향을 행(row), 세로 방향을 열(column) 이라고 합니다.
6. 행렬의 내적(행렬 곱)
 이어서 알아볼 것은 행렬의 내적을 구하는 방법입니다.
 
행렬의 내적은 다음과 같이 구해집니다.
행렬의 곱을 모른다면 다음 내용을 이해 할 수 없으므로
당연히 행렬의 곱을 공부하고 왔어야 합니다.
여기서는 따로 행렬의 곱을 설명하지 않겠습니다.
우리는 이 행렬의 내적 계산법을 numpy를 이용해 구현할 생각입니다.
 
왼쪽을 보면 알 수 있듯이 A*B는 우리가 원하는 결과를 얻을 수 없습니다. 단순하게 일대일 대응하여 곱하여 나오기 때문입니다. 우리가 원하는 내적을 하자면 np.dot()를 사용해야 합니다.
np.dot(A, B)를 통해 AB의 내적을 구한 걸 확인할 수 있습니다.
여기서 주의해야 할 점은
np.dot(A, B)와 np.dot(B, A)는 서로 다르다는 점 입니다.
우리는 그 이유를 AB의 내적과  BA내적이 다르다는 걸로
이미 행렬에서 배워 알고 있습니다.
두번째로 조심해야 할 것은 행렬A의 1번째 차원의 원소 수(열 수)와 행렬  B의 0번째 차원의 원소 수(행 수)가 같아야 합니다.
같지 않을시에는 다음과 같은 오류가 발생합니다. (2x3과 2x2를 곱할 경우)

Traceback (most recent call last):
   File "<stdin>" , line 1, in <module>
ValueError: shape (2,3)and (2,2) not aligned: 3 (dim 1) != 2 (dim 0)
즉, 다차원 배열을 곱하려면 두 행령의 대응하는 차원의 원소 수를 일치시켜야 합니다.
 
왼쪽의 규칙은 A가 2차원이고 B가 1차원 배열일때도 
'대응하는 차원의 원소 수를 일치시켜라' 는 원칙이 똑같이
적용됩니다.
[출처] Python-numpy?|작성자 choiym24

